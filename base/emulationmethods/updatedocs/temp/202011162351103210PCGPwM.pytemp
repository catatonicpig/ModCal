"""Header here."""

import numpy as np
import scipy.optimize as spo
import scipy.linalg as spla
import copy

""" 
This [emulationfitinfo] automatically filled by docinfo.py when running updatedocs.py
##############################################################################
################################### fit ######################################
### The purpose of this is to take information and plug all of our fit
### information into fitinfo, which is a python dictionary. 
##############################################################################
##############################################################################
"""
    Fits a emulation model.
    This [emulationfitdocstring] automatically filled by docinfo.py when running updatedocs.py
    
    Parameters
    ----------
    fitinfo : dict
        An arbitary dictionary where you should place all of your fitting information once complete.
        This dictionary is pass by reference, so there is no reason to return anything. Keep
        only stuff that will be used by predict below.  Note that if you want to leverage speedy,
        updates fitinfo will contain the previous fitinfo!  So use that information to accelerate 
        anything you wany, keeping in mind that the user might have changed theta, f, and x.
    x : array of objects
        An matrix (vector) of inputs. Each row should correspond to a row in f.
    theta :  array of objects
        An matrix (vector) of parameters. Each row should correspond to a row in f.
    f : array of float
        An matrix (vector) of responses.  Each row in f should correspond to a row in x. Each 
        column should correspond to a row in theta.
    args : dict
        A dictionary containing options passed to you.
    f = f.T
    if not np.all(np.isfinite(f)):
        fitinfo['mof'] = np.logical_not(np.isfinite(f))
        fitinfo['mofrows'] = np.where(np.any(fitinfo['mof'] > 0.5,1))[0]
    else:
        fitinfo['mof'] = None
        fitinfo['mofrows'] = None
    #Storing these values for future reference
    fitinfo['x'] = x
    fitinfo['theta'] = theta
    fitinfo['f'] = f
    #The double underline should be used to represent my local functions
    skipstnd = False
    skipPC = True
    if ('offset' in fitinfo.keys()) and ('scale' in fitinfo.keys()):
        __standardizef(fitinfo, fitinfo['offset'], fitinfo['scale'])
    else:
        __standardizef(fitinfo)
        
    if ('pct' in fitinfo.keys()) and ('pcw' in fitinfo.keys()) and\
        ('extravar' in fitinfo.keys()):
        __PCs(fitinfo,fitinfo['pct'],fitinfo['pcw'],fitinfo['extravar'])
    else:
        __PCs(fitinfo)
    numpcs = fitinfo['pc'].shape[1]
    
    if not fitinfo['PCAskip'] or not np.sum(np.isfinite(f)) < 2 * fitinfo['lastup']:
        fitinfo['PCAskip'] = False
        fitinfo['lastup'] = np.sum(np.isfinite(f))
        emulist = [dict() for x in range(0, numpcs)]
        hypinds = np.zeros(numpcs)
    if fitinfo['PCAskip']:
        for pcanum in range(0, numpcs):
            __fitGP1d(theta, fitinfo['pc'][:, pcanum],
                                        fitinfo['pcstdvar'][:, pcanum],
                                        prevsubmodel = fitinfo['emulist'][pcanum])
    else:
        for pcanum in range(0, numpcs):
            if pcanum > 0.5:
                hypwhere = np.where(hypinds == np.array(range(0, numpcs)))[0]
                emulist[pcanum] = __fitGP1d(theta, fitinfo['pc'][:, pcanum],
                                            fitinfo['pcstdvar'][:, pcanum], hypstarts[hypwhere,:],
                                            hypwhere)
            else:
                emulist[pcanum] = __fitGP1d(theta,fitinfo['pc'][:, pcanum],fitinfo['pcstdvar'][:, pcanum])
                hypstarts = np.zeros((numpcs,
                                      emulist[pcanum]['hyp'].shape[0]))
            hypstarts[pcanum, :] = emulist[pcanum]['hyp']
            if emulist[pcanum]['hypind'] < -0.5:
                emulist[pcanum]['hypind'] = pcanum
            hypinds[pcanum] = emulist[pcanum]['hypind']
        fitinfo['emulist'] = emulist
    return


"""
This [emulationpredictinfo] automatically filled by docinfo.py when running updatedocs.py
##############################################################################
################################### predict ##################################
### The purpose of this is to take an emulator emu alongside fitinfo, and 
### predict at x and theta. You shove all your information into the dictionary predinfo.
##############################################################################
##############################################################################
"""
    Finds prediction at theta and x given the dictionary fitinfo.
    This [emulationpredictdocstring] automatically filled by docinfo.py when running updatedocs.py

    Parameters
    ----------
    predinfo : dict
        An arbitary dictionary where you should place all of your prediction information once complete. 
        This dictionary is pass by reference, so there is no reason to return anything. Keep
        only stuff that will be used by predict.  Key elements
        predinfo['mean'] : predinfo['mean'][k] is mean of the prediction at all x at theta[k].
        predinfo['var'] : predinfo['var'][k] is variance of the prediction at all x at theta[k].
        predinfo['cov'] : predinfo['cov'][k] is mean of the prediction at all x at theta[k].
        predinfo['covhalf'] : if A = predinfo['covhalf'][k] then A.T @ A = predinfo['cov'][k]
        predinfo['rand'] : predinfo['rand'][l][k] lth draw of of x at theta[k].
    fitinfo : dict
        An arbitary dictionary where you placed all your important fitting information from the 
        fit function above.
    x : array of objects
        An matrix (vector) of inputs for prediction.
    theta :  array of objects
        An matrix (vector) of parameters to prediction.
    args : dict
        A dictionary containing options passed to you.
    infos = fitinfo['emulist']
    predvecs = np.zeros((theta.shape[0], len(infos)))
    predvars = np.zeros((theta.shape[0], len(infos)))
    if x is not None:
        matchingmatrix = np.ones((x.shape[0], fitinfo['x'].shape[0]))
        for k in range(0,x[0].shape[0]):
            try:
                matchingmatrix *= np.isclose(x[:,k][:,None].astype('float'),
                         fitinfo['x'][:,k].astype('float'))
            except:
                matchingmatrix *= np.equal(x[:,k][:,None],fitinfo['x'][:,k])
        xind = np.argwhere(matchingmatrix > 0.5)[:,1]
        xnewind = np.argwhere(matchingmatrix > 0.5)[:,0]
    else:
        xind = range(0,fitinfo['x'].shape[0])
    rsave = np.array(np.ones(len(infos)), dtype=object)
    for k in range(0, len(infos)):
        if infos[k]['hypind'] == k:
            rsave[k] = __covmat(theta, fitinfo['theta'], infos[k]['hypcov'])
        r = (1-infos[k]['nug']) * np.squeeze(rsave[infos[k]['hypind']])
        rVh = r @ infos[k]['Vh']
        predvecs[:, k] = r @ infos[k]['pw']
        predvars[:, k] = infos[k]['sig2'] * (1 - np.sum(rVh ** 2, 1))
    predinfo['mean'] = np.full((x.shape[0], theta.shape[0]),np.nan)
    predinfo['var'] = np.full((x.shape[0], theta.shape[0]),np.nan)
    predinfo['mean'][xnewind,:] = ((predvecs @ fitinfo['pct'][xind,:].T)*fitinfo['scale'][xind] +\
        fitinfo['offset'][xind]).T
    predinfo['var'][xnewind,:] = ((fitinfo['extravar'][xind] + predvars @ (fitinfo['pct'][xind,:] ** 2).T) *\
        (fitinfo['scale'][xind] ** 2)).T
    CH = (np.sqrt(np.abs(predvars))[:,:,np.newaxis] *
                             (fitinfo['pct'][xind,:].T)[np.newaxis,:,:])
    predinfo['covxhalf'] = np.full((theta.shape[0],CH.shape[1],x.shape[0]), np.nan)
    predinfo['covxhalf'][:,:,xnewind] = CH
    predinfo['covxhalf'] = predinfo['covxhalf'].transpose((1,0,2))
    return

"""
This [emulationadditionalfuncsinfo] automatically filled by docinfo.py when running updatedocs.py
##############################################################################
##############################################################################
####################### THIS ENDS THE REQUIRED PORTION #######################
###### THE NEXT FUNCTIONS ARE OPTIONAL TO BE CALLED BY CALIBRATION ###########
## If this project works, there will be a list of useful calibration functions
## to provide as you want.
##############################################################################
##############################################################################
"""
    Finds supplement theta and x given the dictionary fitinfo.
    This is automatically filled 

    Parameters
    ----------
    fitinfo : dict
        An arbitary dictionary where you placed all your important fitting information from the 
        fit function above.
    x : array
        An array of x values where you want to predict.
    theta : array
        An array of theta values where you want to predict.
    cal : instance of emulator class
        An emulator class instance as defined in calibration.  This will not always be provided.
    args : dict
        A dictionary containing options passed to you.
        
    Returns
    ----------
    Note that we should have theta.shape[0] * x.shape[0] < size
    theta : array
        An array of theta values where you should sample.
    x : array
        An array of x values where you should sample.
    info : array
        An an optional info dictionary you can pass back to the user.
    """
    
    ntheta = size
    infos = copy.copy(fitinfo['emulist'])
    thetaold = copy.copy(fitinfo['theta'])
    norig = thetaold.shape[0]
    varpca = copy.copy(fitinfo['pcstdvar'])
    
    thetaposs = copy.copy(theta)
    if thetaposs.shape[0] > 10 * ntheta:
        thetac = np.random.choice(thetaposs.shape[0], 10 * ntheta, replace=False)
        thetaposs = thetaposs[thetac,:]
    
    rsave = np.array(np.ones(len(infos)), dtype=object)
    rposssave = np.array(np.ones(len(infos)), dtype=object)
    rnewsave = np.array(np.ones(len(infos)), dtype=object)
    R = np.array(np.ones(len(infos)), dtype=object)
    crit = np.zeros(thetaposs.shape[0])
    weightma = np.mean(fitinfo['pct'] ** 2,0)
    for k in range(0, len(infos)):
        if infos[k]['hypind'] == k:
            rsave[k] = (1-infos[k]['nug']) * __covmat(theta, thetaold, infos[k]['hypcov'])
            rposssave[k] = (1-infos[k]['nug']) * __covmat(thetaposs, thetaold, infos[k]['hypcov'])
            rnewsave[k] = (1-infos[k]['nug']) * __covmat(thetaposs, theta, infos[k]['hypcov'])
            R[k] = __covmat(thetaold, thetaold, infos[k]['hypcov'])
            R[k] = (1-infos[k]['nug']) * R[k] + np.eye(R[k].shape[0]) * infos[k]['nug']
    critsave = np.zeros(thetaposs.shape[0])
    for j in range(0,ntheta):
        crit = 0*crit
        if thetaposs.shape[0] < 1.5:
            thetaold = np.vstack((thetaold, thetaposs))
            break
        for k in range(0, len(infos)):
            Rh = R[infos[k]['hypind']] + np.diag(varpca[:, k])
            p = rnewsave[infos[k]['hypind']]
            q = rposssave[infos[k]['hypind']] @ np.linalg.solve(Rh,rsave[infos[k]['hypind']].T)
            r = rposssave[infos[k]['hypind']].T * np.linalg.solve(Rh,rposssave[infos[k]['hypind']].T)
            crit += weightma[k] * np.mean((p-q) ** 2,1) / (1 - np.sum(r,0))
        jstar = np.argmax(crit)
        critsave[j] = crit[jstar]
        thetaold = np.vstack((thetaold, thetaposs[jstar]))
        thetaposs = np.delete(thetaposs, jstar, 0)
        for k in range(0, len(infos)):
            if infos[k]['hypind'] == k:
                R[k] = np.vstack((R[k],rposssave[k][jstar,:]))
                R[k] = np.vstack((R[k].T,np.append(rposssave[k][jstar,:],1))).T
                newr = (1-infos[k]['nug']) * __covmat(thetaposs, thetaold[-1,:], infos[k]['hypcov'])
                rposssave[k] = np.delete(rposssave[k], jstar, 0)
                rposssave[k] = np.hstack((rposssave[k], newr))
                rsave[k] = np.hstack((rsave[k], rnewsave[k][jstar,:][:,None]))
                rnewsave[k] = np.delete(rnewsave[k], jstar, 0)
        crit = np.delete(crit, jstar)
        varpca = np.vstack((varpca,0*varpca[0, :]))
    
    info ={}
    info['crit'] = critsave
    return thetaold[norig:,:], x, info

"""
##############################################################################
##############################################################################
####################### THIS ENDS THE OPTIONAL PORTION #######################
######### USE SPACE BELOW FOR ANY SUPPORTING FUNCTIONS YOU DESIRE ############
##############################################################################
##############################################################################
